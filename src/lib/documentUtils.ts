import { Document } from './mockDocumentData';

// Simulate file download
export const downloadDocument = (document: Document) => {
  // Create a mock file content based on document type
  const mockContent = generateMockFileContent(document);
  
  // Create blob and download
  const blob = new Blob([mockContent], { type: getMimeType(document.format) });
  const url = URL.createObjectURL(blob);
  
  const link = document.createElement('a');
  link.href = url;
  link.download = `${document.name}.${document.format.toLowerCase()}`;
  link.style.display = 'none';
  
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  
  // Clean up
  URL.revokeObjectURL(url);
  
  // Update download count (in real app, this would be sent to server)
  console.log(`Downloaded: ${document.name} (${document.format})`);
};

// Generate mock file content based on document type
const generateMockFileContent = (document: Document): string => {
  const baseContent = `
Q HR Management System
Document: ${document.name}
Type: ${document.type}
Format: ${document.format}
Size: ${document.size} bytes
Uploaded by: ${document.uploadedBy}
Department: ${document.department}
Upload Date: ${document.uploadDate.toISOString()}
Last Modified: ${document.lastModified.toISOString()}
Visibility: ${document.isPublic ? 'Public' : 'Private'}
Download Count: ${document.downloadCount}
Tags: ${document.tags.join(', ')}
${document.description ? `Description: ${document.description}` : ''}

---
This is a mock document generated by Q HR Management System.
In a real application, this would be the actual file content.
  `;

  switch (document.format.toLowerCase()) {
    case 'pdf':
      return `%PDF-1.4\n1 0 obj\n<<\n/Type /Catalog\n/Pages 2 0 R\n>>\nendobj\n2 0 obj\n<<\n/Type /Pages\n/Kids [3 0 R]\n/Count 1\n>>\nendobj\n3 0 obj\n<<\n/Type /Page\n/Parent 2 0 R\n/MediaBox [0 0 612 792]\n/Contents 4 0 R\n>>\nendobj\n4 0 obj\n<<\n/Length 44\n>>\nstream\nBT\n/F1 12 Tf\n72 720 Td\n(${document.name}) Tj\nET\nendstream\nendobj\nxref\n0 5\n0000000000 65535 f \n0000000009 00000 n \n0000000058 00000 n \n0000000115 00000 n \n0000000204 00000 n \ntrailer\n<<\n/Size 5\n/Root 1 0 R\n>>\nstartxref\n297\n%%EOF`;
    
    case 'doc':
    case 'docx':
      return `Microsoft Word Document\n\n${baseContent}`;
    
    case 'xls':
    case 'xlsx':
      return `Microsoft Excel Spreadsheet\n\n${baseContent}`;
    
    case 'ppt':
    case 'pptx':
      return `Microsoft PowerPoint Presentation\n\n${baseContent}`;
    
    case 'txt':
      return baseContent;
    
    case 'jpg':
    case 'png':
      // For images, we'll create a simple text file as placeholder
      return `Image File: ${document.name}\n\n${baseContent}`;
    
    default:
      return baseContent;
  }
};

// Get MIME type based on file format
const getMimeType = (format: string): string => {
  const mimeTypes: Record<string, string> = {
    'PDF': 'application/pdf',
    'DOC': 'application/msword',
    'DOCX': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
    'XLS': 'application/vnd.ms-excel',
    'XLSX': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
    'PPT': 'application/vnd.ms-powerpoint',
    'PPTX': 'application/vnd.openxmlformats-officedocument.presentationml.presentation',
    'TXT': 'text/plain',
    'JPG': 'image/jpeg',
    'PNG': 'image/png'
  };
  
  return mimeTypes[format] || 'application/octet-stream';
};

// Share document (mock implementation)
export const shareDocument = (document: Document) => {
  if (navigator.share) {
    navigator.share({
      title: document.name,
      text: `Check out this document: ${document.name}`,
      url: document.fileUrl || '#'
    }).catch(console.error);
  } else {
    // Fallback: copy to clipboard
    const shareText = `Document: ${document.name}\nType: ${document.type}\nFormat: ${document.format}\nSize: ${document.size} bytes\nUploaded by: ${document.uploadedBy}`;
    
    navigator.clipboard.writeText(shareText).then(() => {
      alert('Document information copied to clipboard!');
    }).catch(() => {
      alert('Unable to copy to clipboard. Please try again.');
    });
  }
};

// Bulk download multiple documents
export const downloadMultipleDocuments = (documents: Document[]) => {
  documents.forEach((doc, index) => {
    // Add delay between downloads to avoid browser blocking
    setTimeout(() => {
      downloadDocument(doc);
    }, index * 500);
  });
};

// Get document statistics
export const getDocumentStats = (documents: Document[]) => {
  const totalSize = documents.reduce((sum, doc) => sum + doc.size, 0);
  const totalDownloads = documents.reduce((sum, doc) => sum + doc.downloadCount, 0);
  
  const typeStats = documents.reduce((stats, doc) => {
    stats[doc.type] = (stats[doc.type] || 0) + 1;
    return stats;
  }, {} as Record<string, number>);
  
  const formatStats = documents.reduce((stats, doc) => {
    stats[doc.format] = (stats[doc.format] || 0) + 1;
    return stats;
  }, {} as Record<string, number>);
  
  const departmentStats = documents.reduce((stats, doc) => {
    stats[doc.department] = (stats[doc.department] || 0) + 1;
    return stats;
  }, {} as Record<string, number>);
  
  return {
    totalDocuments: documents.length,
    totalSize,
    totalDownloads,
    averageSize: totalSize / documents.length,
    typeStats,
    formatStats,
    departmentStats
  };
};

// Validate file before upload
export const validateFile = (file: File): { valid: boolean; error?: string } => {
  const maxSize = 10 * 1024 * 1024; // 10MB
  const allowedTypes = [
    'application/pdf',
    'application/msword',
    'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
    'application/vnd.ms-excel',
    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
    'application/vnd.ms-powerpoint',
    'application/vnd.openxmlformats-officedocument.presentationml.presentation',
    'text/plain',
    'image/jpeg',
    'image/png'
  ];
  
  if (file.size > maxSize) {
    return { valid: false, error: 'File size exceeds 10MB limit' };
  }
  
  if (!allowedTypes.includes(file.type)) {
    return { valid: false, error: 'File type not supported' };
  }
  
  return { valid: true };
};

// Generate document preview URL (mock)
export const getDocumentPreviewUrl = (document: Document): string => {
  // In a real app, this would generate a preview URL from the file server
  return `/api/documents/${document.id}/preview`;
};

// Generate thumbnail URL (mock)
export const getDocumentThumbnailUrl = (document: Document): string => {
  // In a real app, this would generate a thumbnail URL
  return `/api/documents/${document.id}/thumbnail`;
};
